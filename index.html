<!DOCTYPE html>
<html>
<head>
  <title>Escape The Loop â€“ Ultimate Edition</title>
  <style>
    body {
      margin: 0;
      background: linear-gradient(135deg, #0a0a0a, #1a1a2e, #16213e);
      color: white;
      text-align: center;
      font-family: 'Courier New', monospace;
      overflow: hidden;
    }
    canvas {
      background: linear-gradient(45deg, #111, #222, #333);
      display: block;
      margin: 10px auto;
      border: 5px solid #00ff88;
      box-shadow: 0 0 40px rgba(0,255,136,0.6),
                  inset 0 0 20px rgba(255,0,255,0.2);
      border-radius: 15px;
      max-width: 90vw;
      max-height: 85vh;
    }
    .title {
      font-size: 32px;
      color: #00ff88;
      text-shadow: 0 0 25px rgba(0,255,136,1),
                   0 0 50px rgba(255,0,255,0.5);
      margin: 10px 0;
      font-weight: bold;
    }
    .instructions {
      font-size: 18px;
      color: #ffaa00;
      margin: 5px 0;
      text-shadow: 0 0 10px rgba(255,170,0,0.8);
    }
  </style>
</head>
<body>
  <div class="title">âœ¨ ESCAPE THE LOOP âœ¨</div>
  <div class="instructions">
    ðŸ”‘ Use ARROW KEYS to move â€¢ Collect 3 KEYS to activate portal â€¢ Avoid enemies ðŸ”´
  </div>
  <canvas id="gameCanvas" width="800" height="700"></canvas>

  <script>
    // --- CONSTANTS & GLOBALS ---
    const canvas      = document.getElementById("gameCanvas");
    const ctx         = canvas.getContext("2d");
    const tileSize    = 45;
    const mazeOffsetX = 40;
    const mazeOffsetY = 80;
    const MOVE_COOLDOWN = 8;

    let gameStarted   = false,
        gameOver      = false,
        victory       = false,
        currentLevel  = 0,
        score         = 0,
        keysCollected = 0,
        messageTimer  = 0,
        levelMessage  = "",
        transitioning = false,
        transitionProgress = 0,
        animationTime = 0,
        moveDelay     = 0;

    // --- PLAYER STATE ---
    let player = {
      x:1, y:1,
      targetX:1, targetY:1,
      floatX:1, floatY:1,
      angle:0, scale:1,
      moving:false,
      trail:[]
    };

    // --- INPUT HANDLING ---
    let keysPressed = {};
    document.addEventListener("keydown", e => {
      if (!gameStarted && e.key === "Enter") {
        gameStarted = true;
        resetLevel();
        return;
      }
      if (e.key === "r" || e.key === "R") {
        restartGame();
        return;
      }
      if (!keysPressed[e.key] && moveDelay <= 0) {
        keysPressed[e.key] = true;
        handleMovement(e.key);
      }
    });
    document.addEventListener("keyup", e => {
      delete keysPressed[e.key];
    });

    // --- DIRECTION VECTORS ---
    const ENEMY_DIRS = [
      {x:0,y:-1}, {x:1,y:0}, {x:0,y:1}, {x:-1,y:0}
    ];

    // --- LEVEL DEFINITIONS (1â€“10) ---
    let levels = [
      // Level 1
      {
        maze:[
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
          [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
          [1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1],
          [1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,1],
          [1,1,1,0,1,1,1,0,1,0,1,1,0,1,0,1],
          [1,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1],
          [1,0,1,1,1,1,1,0,1,0,1,0,1,1,0,1],
          [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1],
          [1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1],
          [1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1],
          [1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1],
          [1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1],
          [1,0,1,1,1,1,1,1,1,1,1,1,0,1,0,1],
          [1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ],
        enemies:[
          {x:5,y:5,floatX:5,floatY:5,speed:0.015,direction:0,moveTimer:0,color:'#ff4444'},
          {x:10,y:9,floatX:10,floatY:9,speed:0.012,direction:1,moveTimer:0,color:'#ff6666'},
          {x:3,y:11,floatX:3,floatY:11,speed:0.018,direction:2,moveTimer:0,color:'#ff8888'}
        ],
        keys:[
          {x:13,y:1,pulse:0},
          {x:1,y:13,pulse:0.5},
          {x:13,y:13,pulse:1}
        ],
        diamonds:[
          {x:8,y:7,rotation:0}
        ],
        portal:{x:14,y:13,pulse:1,active:false,particles:[]}
      },
      // Level 2
      JSON.parse(JSON.stringify(this[0])),
      // Level 3
      JSON.parse(JSON.stringify(this[0])),
      // Level 4
      JSON.parse(JSON.stringify(this[0])),
      // Level 5
      JSON.parse(JSON.stringify(this[0])),
      // Level 6
      {
        maze:[
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
          [1,0,1,0,0,1,1,0,1,0,0,1,0,1,0,1],
          [1,0,1,1,0,1,1,0,1,1,0,1,0,1,0,1],
          [1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1],
          [1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1],
          [1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1],
          [1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,1],
          [1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1],
          [1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1],
          [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,1],
          [1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,1],
          [1,0,0,1,0,0,0,0,0,0,0,1,0,1,0,1],
          [1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1],
          [1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ],
        enemies:[
          {x:4,y:4,floatX:4,floatY:4,speed:0.018,direction:0,moveTimer:0,color:'#ff3322'},
          {x:11,y:8,floatX:11,floatY:8,speed:0.020,direction:1,moveTimer:0,color:'#ff5544'},
          {x:7,y:11,floatX:7,floatY:11,speed:0.016,direction:2,moveTimer:0,color:'#ff7766'},
          {x:2,y:2,floatX:2,floatY:2,speed:0.019,direction:3,moveTimer:0,color:'#ff9988'}
        ],
        keys:[
          {x:1,y:1,pulse:0},
          {x:14,y:1,pulse:0.5},
          {x:8,y:13,pulse:1}
        ],
        diamonds:[
          {x:3,y:7,rotation:0},
          {x:12,y:5,rotation:1}
        ],
        portal:{x:14,y:13,pulse:1,active:false,particles:[]}
      },
      // Level 7
      {
        maze:[
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
          [1,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1],
          [1,1,0,1,1,0,1,0,1,1,0,1,1,1,0,1],
          [1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1],
          [1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,1],
          [1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1],
          [1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,1],
          [1,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1],
          [1,1,1,1,1,1,0,1,0,1,1,1,0,1,0,1],
          [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,1],
          [1,0,1,1,0,1,1,0,1,1,0,1,1,1,0,1],
          [1,0,0,1,0,0,0,0,0,0,0,1,0,1,0,1],
          [1,1,0,1,1,1,1,1,1,1,0,1,0,1,0,1],
          [1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1],
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ],
        enemies:[
          {x:3,y:5,floatX:3,floatY:5,speed:0.020,direction:2,moveTimer:0,color:'#ffaa00'},
          {x:9,y:9,floatX:9,floatY:9,speed:0.022,direction:1,moveTimer:0,color:'#ffee22'},
          {x:6,y:2,floatX:6,floatY:2,speed:0.018,direction:3,moveTimer:0,color:'#ffcc00'}
        ],
        keys:[
          {x:1,y:13,pulse:0},
          {x:14,y:3,pulse:0.5},
          {x:7,y:7,pulse:1}
        ],
        diamonds:[
          {x:4,y:4,rotation:0},
          {x:12,y:12,rotation:1},
          {x:2,y:10,rotation:2}
        ],
        portal:{x:14,y:13,pulse:1,active:false,particles:[]}
      },
      // Level 8
      {
        maze:[
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
          [1,0,1,0,0,0,1,0,1,0,1,0,0,0,0,1],
          [1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,1],
          [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1],
          [1,1,1,0,1,1,1,1,1,1,1,0,1,0,1,1],
          [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],
          [1,0,1,1,1,1,1,0,1,1,1,1,1,1,0,1],
          [1,0,0,0,0,0,1,0,1,0,0,0,0,1,0,1],
          [1,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1],
          [1,0,0,0,0,0,1,0,1,0,0,0,0,1,0,1],
          [1,0,1,1,1,1,1,0,1,1,1,1,0,1,0,1],
          [1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1],
          [1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1],
          [1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1],
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ],
        enemies:[
          {x:5,y:6,floatX:5,floatY:6,speed:0.022,direction:0,moveTimer:0,color:'#22ff22'},
          {x:10,y:3,floatX:10,floatY:3,speed:0.020,direction:1,moveTimer:0,color:'#44ff44'},
          {x:7,y:12,floatX:7,floatY:12,speed:0.021,direction:2,moveTimer:0,color:'#66ff66'},
          {x:2,y:8,floatX:2,floatY:8,speed:0.019,direction:3,moveTimer:0,color:'#88ff88'}
        ],
        keys:[
          {x:1,y:1,pulse:0},
          {x:14,y:1,pulse:0.5},
          {x:8,y:14,pulse:1}
        ],
        diamonds:[
          {x:3,y:3,rotation:0},
          {x:12,y:7,rotation:1},
          {x:6,y:10,rotation:2},
          {x:10,y:13,rotation:3}
        ],
        portal:{x:14,y:13,pulse:1,active:false,particles:[]}
      },
      // Level 9
      {
        maze:[
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
          [1,0,1,0,1,0,0,0,0,1,0,1,0,0,0,1],
          [1,0,1,0,1,1,1,1,0,1,0,1,1,1,0,1],
          [1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1],
          [1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1],
          [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,1],
          [1,0,1,1,0,1,1,1,0,1,1,1,0,1,0,1],
          [1,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1],
          [1,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1],
          [1,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1],
          [1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,1],
          [1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1],
          [1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1],
          [1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1],
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ],
        enemies:[
          {x:3,y:3,floatX:3,floatY:3,speed:0.024,direction:0,moveTimer:0,color:'#ff00ff'},
          {x:8,y:8,floatX:8,floatY:8,speed:0.023,direction:1,moveTimer:0,color:'#dd00dd'},
          {x:5,y:11,floatX:5,floatY:11,speed:0.022,direction:2,moveTimer:0,color:'#bb00bb'},
          {x:11,y:5,floatX:11,floatY:5,speed:0.021,direction:3,moveTimer:0,color:'#990099'},
          {x:7,y:7,floatX:7,floatY:7,speed:0.020,direction:0,moveTimer:0,color:'#770077'}
        ],
        keys:[
          {x:1,y:13,pulse:0},
          {x:14,y:2,pulse:0.5},
          {x:2,y:6,pulse:1}
        ],
        diamonds:[
          {x:4,y:12,rotation:0},
          {x:10,y:2,rotation:1},
          {x:12,y:10,rotation:2}
        ],
        portal:{x:14,y:13,pulse:1,active:false,particles:[]}
      },
      // Level 10
      {
        maze:[
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
          [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1],
          [1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1],
          [1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,1],
          [1,0,1,1,1,0,1,0,1,0,1,1,1,1,0,1],
          [1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],
          [1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1],
          [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
          [1,0,1,1,1,1,1,0,1,1,1,1,1,1,0,1],
          [1,0,1,0,0,0,1,0,0,0,0,0,0,1,0,1],
          [1,0,1,0,1,0,1,1,1,1,1,1,0,1,0,1],
          [1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1],
          [1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1],
          [1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
          [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ],
        enemies:[
          {x:4,y:4,floatX:4,floatY:4,speed:0.026,direction:0,moveTimer:0,color:'#ff4444'},
          {x:9,y:9,floatX:9,floatY:9,speed:0.025,direction:1,moveTimer:0,color:'#ff6666'},
          {x:6,y:12,floatX:6,floatY:12,speed:0.024,direction:2,moveTimer:0,color:'#ff8888'},
          {x:2,y:6,floatX:2,floatY:6,speed:0.023,direction:3,moveTimer:0,color:'#ffaa00'},
          {x:11,y:3,floatX:11,floatY:3,speed:0.022,direction:0,moveTimer:0,color:'#ffee22'},
          {x:7,y:8,floatX:7,floatY:8,speed:0.021,direction:1,moveTimer:0,color:'#cc00cc'}
        ],
        keys:[
          {x:1,y:1,pulse:0},
          {x:14,y:14,pulse:0.5},
          {x:8,y:8,pulse:1}
        ],
        diamonds:[
          {x:3,y:10,rotation:0},
          {x:12,y:6,rotation:1},
          {x:6,y:3,rotation:2},
          {x:10,y:12,rotation:3}
        ],
        portal:{x:14,y:13,pulse:1,active:false,particles:[]}
      }
    ];

    // --- MOVEMENT & COLLISION LOGIC ---
    function handleMovement(key) {
      if (gameOver || !gameStarted || messageTimer>0 || victory || transitioning || player.moving)
        return;
      let dx=0, dy=0;
      if (key==="ArrowUp")    dy=-1;
      if (key==="ArrowDown")  dy=1;
      if (key==="ArrowLeft")  dx=-1;
      if (key==="ArrowRight") dx=1;
      if (!dx && !dy) return;

      let nx = player.x + dx,
          ny = player.y + dy,
          maze = levels[currentLevel].maze;
      if (maze[ny]?.[nx] === 0) {
        // trail
        player.trail.push({x:player.floatX, y:player.floatY, life:20});
        if (player.trail.length>10) player.trail.shift();

        player.x=nx; player.y=ny;
        player.targetX=nx; player.targetY=ny;
        player.moving=true;
        moveDelay=MOVE_COOLDOWN;

        // keys
        levels[currentLevel].keys = levels[currentLevel].keys.filter(k=>{
          if (k.x===nx && k.y===ny){
            keysCollected++;
            score+=100;
            levelMessage = `ðŸ”‘ Key collected! ${3-keysCollected} remaining`;
            messageTimer=60;
            return false;
          }
          return true;
        });
        // diamonds
        levels[currentLevel].diamonds = levels[currentLevel].diamonds.filter(d=>{
          if (d.x===nx && d.y===ny){
            score+=500;
            levelMessage="ðŸ’Ž Diamond collected! +500";
            messageTimer=60;
            return false;
          }
          return true;
        });
      }
    }

    function updatePlayer() {
      if (player.moving) {
        let dx = player.targetX - player.floatX,
            dy = player.targetY - player.floatY,
            speed=0.25;
        player.floatX += dx*speed;
        player.floatY += dy*speed;
        if (Math.abs(dx)<0.1 && Math.abs(dy)<0.1) {
          player.floatX=player.targetX;
          player.floatY=player.targetY;
          player.moving=false;
        }
      }
      player.trail.forEach(t=>t.life--);
      player.trail = player.trail.filter(t=>t.life>0);
      if (moveDelay>0) moveDelay--;
    }

    // --- SMARTER, SLOWER ENEMIES ---
    function findPath(sx,sy,tx,ty,maze){
      const keyOf=p=>`${p.x},${p.y}`;
      let frontier=[{x:sx,y:sy}], cameFrom={};
      cameFrom[keyOf({x:sx,y:sy})]=null;
      while(frontier.length){
        let cur=frontier.shift();
        if(cur.x===tx && cur.y===ty) break;
        for(let d of ENEMY_DIRS){
          let nx=cur.x+d.x, ny=cur.y+d.y, k=keyOf({x:nx,y:ny});
          if(maze[ny]?.[nx]===0 && !(k in cameFrom)){
            frontier.push({x:nx,y:ny});
            cameFrom[k]=cur;
          }
        }
      }
      let path=[], step={x:tx,y:ty};
      while(step){
        path.unshift(step);
        step=cameFrom[keyOf(step)];
      }
      return path;
    }

    function roamRandom(e,maze){
      e.moveTimer++;
      if(e.moveTimer>120){
        let valid=[];
        ENEMY_DIRS.forEach((d,i)=>{
          let nx=Math.floor(e.floatX+d.x),
              ny=Math.floor(e.floatY+d.y);
          if(maze[ny]?.[nx]===0) valid.push(i);
        });
        if(valid.length) e.direction=valid[Math.floor(Math.random()*valid.length)];
        e.moveTimer=0;
      }
      let d=ENEMY_DIRS[e.direction],
          nx=e.floatX+d.x*e.speed,
          ny=e.floatY+d.y*e.speed;
      if(maze[Math.floor(ny)]?.[Math.floor(nx)]===0){
        e.floatX=nx; e.floatY=ny;
      } else {
        e.moveTimer=120;
      }
      e.x=Math.round(e.floatX);
      e.y=Math.round(e.floatY);
    }

    function moveEnemiesSmart(){
      let lvl=levels[currentLevel],
          maze=lvl.maze,
          px=player.x, py=player.y;
      lvl.enemies.forEach(e=>{
        let ex=Math.floor(e.floatX),
            ey=Math.floor(e.floatY),
            dist=Math.hypot(px-ex,py-ey);

        if(dist<7){
          // chase
          e.repath=(e.repath||0)-1;
          if(e.repath<=0){
            e.path=findPath(ex,ey,px,py,maze);
            e.repath=30;
          }
          if(e.path && e.path.length>1){
            let nxt=e.path[1],
                dx=nxt.x-e.floatX,
                dy=nxt.y-e.floatY,
                slow=e.speed*0.4;
            e.floatX+=dx*slow;
            e.floatY+=dy*slow;
          } else roamRandom(e,maze);
        } else {
          roamRandom(e,maze);
        }

        // collision
        if(Math.abs(e.floatX-player.floatX)<0.7 &&
           Math.abs(e.floatY-player.floatY)<0.7){
          gameOver=true;
          levelMessage="ðŸ’€ CAUGHT! Press R to restart ðŸ’€";
          messageTimer=300;
        }
      });
    }

    // --- PORTAL & TRANSITIONS ---
    function portalPull(){
      if(transitioning) return;
      let lvl=levels[currentLevel], p=lvl.portal;
      if(keysCollected>=3 && !p.active){
        p.active=true;
        levelMessage="ðŸŒ€ PORTAL ACTIVATED! Enter to proceed! ðŸŒ€";
        messageTimer=120;
        p.particles=[];
        for(let i=0;i<20;i++){
          p.particles.push({
            angle:(i/20)*Math.PI*2,
            radius:30+Math.random()*20,
            speed:0.02+Math.random()*0.01
          });
        }
      }
      if(!p.active) return;
      p.particles.forEach(pt=>{
        pt.angle+=pt.speed;
        pt.radius*=0.995;
        if(pt.radius<5) pt.radius=50;
      });
      let dx=(p.x+0.5)-player.floatX,
          dy=(p.y+0.5)-player.floatY,
          dist=Math.hypot(dx,dy);
      if(dist<3.5){
        let pull=0.012+(3.5-dist)*0.018;
        player.floatX+=dx*pull;
        player.floatY+=dy*pull;
        player.targetX=player.floatX;
        player.targetY=player.floatY;
        player.x=Math.round(player.floatX);
        player.y=Math.round(player.floatY);
        player.angle+=0.08+(3.5-dist)*0.12;
        player.scale=Math.max(0.3,dist/3.5);
        p.pulse=1+(3.5-dist)*0.4;
        if(dist<0.4){
          transitioning=true;
          transitionProgress=0;
        }
      } else {
        player.angle*=0.95;
        if(Math.abs(player.angle)<0.1) player.angle=0;
        player.scale=Math.min(1,player.scale+0.05);
        p.pulse=Math.max(1,p.pulse-0.02);
      }
    }

    function handleTransition(){
      if(!transitioning) return;
      transitionProgress+=0.025;
      if(transitionProgress>=1){
        transitioning=false;
        currentLevel++;
        if(currentLevel>=levels.length){
          victory=true;
          levelMessage="ðŸŽ‰âœ¨ ULTIMATE VICTORY! You escaped all loops! âœ¨ðŸŽ‰";
          messageTimer=600;
        } else {
          score+=1000;
          resetLevel();
        }
      }
    }

    // --- RESET & RESTART ---
    function resetLevel(){
      let lvl=levels[currentLevel];
      player.x=1; player.y=1;
      player.floatX=1; player.floatY=1;
      player.targetX=1; player.targetY=1;
      player.angle=0; player.scale=1; player.moving=false;
      player.trail=[];
      keysCollected=0; gameOver=false; victory=false;
      transitioning=false; transitionProgress=0; moveDelay=0;
      lvl.enemies.forEach(e=>{
        e.floatX=e.x; e.floatY=e.y;
        e.direction=Math.floor(Math.random()*4);
        e.moveTimer=Math.random()*60;
      });
      lvl.portal.active=false;
      lvl.portal.particles=[];
      levelMessage=`ðŸŒŸ Level ${currentLevel+1}: Collect 3 KEYS to activate the portal! ðŸŒŸ`;
      messageTimer=180;
    }

    function restartGame(){
      currentLevel=0; score=0; gameStarted=false;
      gameOver=false; victory=false; transitionProgress=0;
      animationTime=0; moveDelay=0;
      player.x=1; player.y=1; player.floatX=1; player.floatY=1;
      player.targetX=1; player.targetY=1; player.angle=0; player.scale=1;
      player.moving=false; player.trail=[];
      levels.forEach(lvl=>{
        lvl.enemies.forEach(e=>{
          e.floatX=e.x; e.floatY=e.y;
          e.direction=Math.floor(Math.random()*4);
        });
        lvl.portal.active=false;
        lvl.portal.particles=[];
      });
      keysCollected=0; messageTimer=0; levelMessage="";
    }

    // --- RENDERING LOOP ---
    function draw(){
      animationTime+=0.02;
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // Maze border
      let borderG = ctx.createLinearGradient(0,0,canvas.width,canvas.height);
      borderG.addColorStop(0,'#00ff88');
      borderG.addColorStop(0.25,'#0088ff');
      borderG.addColorStop(0.5,'#ff00ff');
      borderG.addColorStop(0.75,'#ffaa00');
      borderG.addColorStop(1,'#00ff88');
      ctx.strokeStyle = borderG;
      ctx.lineWidth = 4;
      let maze = levels[currentLevel].maze;
      ctx.strokeRect(
        mazeOffsetX-3, mazeOffsetY-3,
        maze[0].length*tileSize+6,
        maze.length*tileSize+6
      );

      // Maze walls
      for(let y=0;y<maze.length;y++){
        for(let x=0;x<maze[y].length;x++){
          if(maze[y][x]===1){
            let wg = ctx.createLinearGradient(
              mazeOffsetX+x*tileSize, mazeOffsetY+y*tileSize,
              mazeOffsetX+x*tileSize+tileSize, mazeOffsetY+y*tileSize+tileSize
            );
            wg.addColorStop(0,'#333366');
            wg.addColorStop(0.5,'#444477');
            wg.addColorStop(1,'#555588');
            ctx.fillStyle=wg;
            ctx.fillRect(
              mazeOffsetX+x*tileSize,
              mazeOffsetY+y*tileSize,
              tileSize,tileSize
            );
            ctx.strokeStyle='#6666aa';
            ctx.lineWidth=1;
            ctx.strokeRect(
              mazeOffsetX+x*tileSize,
              mazeOffsetY+y*tileSize,
              tileSize,tileSize
            );
          }
        }
      }

      // Player trail
      player.trail.forEach(t=>{
        let alpha = t.life/20;
        ctx.save();
        ctx.globalAlpha = alpha*0.6;
        ctx.fillStyle='#00ffff';
        ctx.shadowColor='#00ffff';
        ctx.shadowBlur=10;
        ctx.fillRect(
          mazeOffsetX+t.x*tileSize+16,
          mazeOffsetY+t.y*tileSize+16,
          8,8
        );
        ctx.restore();
      });

      // Keys
      levels[currentLevel].keys.forEach((k,i)=>{
        k.pulse += 0.05;
        let glow = Math.sin(animationTime*3 + k.pulse)*0.4+0.6;
        let hue = (animationTime*50 + i*120)%360;
        ctx.save();
        ctx.shadowColor=`hsl(${hue},100%,50%)`;
        ctx.shadowBlur=20*glow;
        ctx.fillStyle=`hsl(${hue},100%,${50+glow*30}%)`;
        let keyX = mazeOffsetX + k.x*tileSize + 20;
        let keyY = mazeOffsetY + k.y*tileSize + 20;
        ctx.translate(keyX,keyY);
        ctx.scale(1+glow*0.2,1+glow*0.2);
        ctx.fillRect(-8,-4,12,8);
        ctx.fillRect(4,-6,4,4);
        ctx.fillRect(4,2,4,4);
        ctx.restore();
      });

      // Diamonds
      levels[currentLevel].diamonds.forEach((d,i)=>{
        d.rotation += 0.02;
        let sparkle = Math.sin(animationTime*4 + i*2)*0.4+0.6;
        let hue = (animationTime*100 + i*60)%360;
        ctx.save();
        ctx.shadowColor=`hsl(${hue},100%,70%)`;
        ctx.shadowBlur=25*sparkle;
        ctx.fillStyle=`hsl(${hue},100%,${60+sparkle*30}%)`;
        ctx.translate(
          mazeOffsetX + d.x*tileSize + 20,
          mazeOffsetY + d.y*tileSize + 20
        );
        ctx.rotate(d.rotation);
        ctx.scale(1+sparkle*0.3,1+sparkle*0.3);
        ctx.beginPath();
        ctx.moveTo(0,-18);
        [ [12,-6],[18,0],[12,6],[0,18],[-12,6],[-18,0],[-12,-6] ]
          .forEach(([x,y])=>ctx.lineTo(x,y));
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      });

      // Portal & particles
      let p = levels[currentLevel].portal;
      ctx.save();
      ctx.translate(
        mazeOffsetX + p.x*tileSize + 20,
        mazeOffsetY + p.y*tileSize + 20
      );
      if(p.active){
        p.particles.forEach(pt=>{
          let x = Math.cos(pt.angle)*pt.radius;
          let y = Math.sin(pt.angle)*pt.radius;
          let hue = (pt.angle*180/Math.PI + animationTime*100)%360;
          ctx.save();
          ctx.globalAlpha = 0.8;
          ctx.fillStyle = `hsl(${hue},100%,60%)`;
          ctx.shadowColor = `hsl(${hue},100%,50%)`;
          ctx.shadowBlur = 15;
          ctx.beginPath();
          ctx.arc(x,y,3,0,Math.PI*2);
          ctx.fill();
          ctx.restore();
        });
        for(let layer=0;layer<5;layer++){
          ctx.save();
          ctx.rotate(animationTime*(2+layer*0.3)*(layer%2?1:-1));
          ctx.scale(p.pulse*(0.6+layer*0.15),p.pulse*(0.6+layer*0.15));
          let hue = (animationTime*80 + layer*72)%360;
          ctx.strokeStyle = `hsl(${hue},100%,${70-layer*5}%)`;
          ctx.lineWidth = 4-layer*0.6;
          ctx.shadowColor = ctx.strokeStyle;
          ctx.shadowBlur = 15;
          for(let i=0;i<8;i++){
            ctx.beginPath();
            let radius = 10 + layer*4;
            let start = (i/8)*Math.PI*2;
            ctx.arc(0,0,radius,start,start+Math.PI*1.3);
            ctx.stroke();
          }
          ctx.restore();
        }
        // center
        ctx.save();
        ctx.scale(p.pulse*0.5,p.pulse*0.5);
        let cg = ctx.createRadialGradient(0,0,0,0,0,20);
        cg.addColorStop(0,'rgba(255,255,255,0.9)');
        cg.addColorStop(0.5,'rgba(255,0,255,0.6)');
        cg.addColorStop(1,'rgba(255,0,255,0)');
        ctx.fillStyle = cg;
        ctx.beginPath();
        ctx.arc(0,0,20,0,Math.PI*2);
        ctx.fill();
        ctx.restore();
      } else {
        ctx.strokeStyle="rgba(100,50,100,0.6)";
        ctx.lineWidth=2;
        ctx.setLineDash([5,5]);
        ctx.beginPath();
        ctx.arc(0,0,15,0,Math.PI*2);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      ctx.restore();

      // Enemies
      levels[currentLevel].enemies.forEach((e,i)=>{
        let pulse = Math.sin(animationTime*6 + i)*0.3+0.7;
        ctx.save();
        ctx.fillStyle=e.color;
        ctx.shadowColor=e.color;
        ctx.shadowBlur=25*pulse;
        let size = 28 + pulse*6;
        ctx.fillRect(
          mazeOffsetX + e.floatX*tileSize + (40-size)/2,
          mazeOffsetY + e.floatY*tileSize + (40-size)/2,
          size, size
        );
        // eyes
        ctx.fillStyle='#ffffff';
        ctx.shadowBlur=5;
        ctx.fillRect(
          mazeOffsetX + e.floatX*tileSize + 8,
          mazeOffsetY + e.floatY*tileSize + 12,
          6,6
        );
        ctx.fillRect(
          mazeOffsetX + e.floatX*tileSize + 26,
          mazeOffsetY + e.floatY*tileSize + 12,
          6,6
        );
        ctx.fillStyle='#000';
        ctx.shadowBlur=0;
        ctx.fillRect(
          mazeOffsetX + e.floatX*tileSize + 10,
          mazeOffsetY + e.floatY*tileSize + 14,
          2,2
        );
        ctx.fillRect(
          mazeOffsetX + e.floatX*tileSize + 28,
          mazeOffsetY + e.floatY*tileSize + 14,
          2,2
        );
        ctx.restore();
      });

      // Player
      ctx.save();
      ctx.translate(
        mazeOffsetX + player.floatX*tileSize + 20,
        mazeOffsetY + player.floatY*tileSize + 20
      );
      ctx.rotate(player.angle);
      ctx.scale(player.scale, player.scale);
      let ph = (animationTime*120)%360;
      let pg = ctx.createRadialGradient(0,0,0,0,0,20);
      pg.addColorStop(0,`hsl(${ph},100%,80%)`);
      pg.addColorStop(0.7,`hsl(${ph},100%,60%)`);
      pg.addColorStop(1,`hsl(${ph},100%,40%)`);
      ctx.shadowColor=`hsl(${ph},100%,50%)`;
      ctx.shadowBlur=30*(Math.sin(animationTime*4)*0.3+0.7);
      ctx.fillStyle=pg;
      ctx.fillRect(-18,-18,36,36);
      ctx.shadowBlur=15;
      ctx.fillStyle='#fff';
      ctx.fillRect(-10,-10,20,20);
      ctx.shadowBlur=5;
      ctx.fillStyle=`hsl(${(ph+180)%360},100%,50%)`;
      ctx.fillRect(-4,-4,8,8);
      ctx.restore();

      // HUD
      ctx.shadowBlur=0;
      let hudG = ctx.createLinearGradient(0,0,canvas.width,60);
      hudG.addColorStop(0,'rgba(0,0,0,0.8)');
      hudG.addColorStop(0.5,'rgba(20,20,40,0.9)');
      hudG.addColorStop(1,'rgba(0,0,0,0.8)');
      ctx.fillStyle=hudG;
      ctx.fillRect(0,0,canvas.width,70);

      ctx.font="bold 24px Courier New";
      let lg = ctx.createLinearGradient(0,0,200,0);
      lg.addColorStop(0,'#00ff88');
      lg.addColorStop(1,'#0088ff');
      ctx.fillStyle=lg;
      ctx.fillText(`ðŸŒŸ LEVEL: ${currentLevel+1}`,30,35);

      let kg = ctx.createLinearGradient(0,0,150,0);
      kg.addColorStop(0,'#ffaa00');
      kg.addColorStop(1,'#ff6600');
      ctx.fillStyle=kg;
      ctx.fillText(`ðŸ”‘ KEYS: ${keysCollected}/3`,250,35);

      let sg = ctx.createLinearGradient(0,0,200,0);
      sg.addColorStop(0,'#ff00ff');
      sg.addColorStop(1,'#ff0088');
      ctx.fillStyle=sg;
      ctx.fillText(`ðŸ’Ž SCORE: ${score}`,450,35);

      if(keysCollected>=3){
        ctx.save();
        let pglo = Math.sin(animationTime*8)*0.5+0.5;
        ctx.fillStyle=`rgba(255,0,255,${0.7+pglo*0.3})`;
        ctx.font="bold 20px Courier New";
        ctx.shadowColor='#ff00ff';
        ctx.shadowBlur=10;
        ctx.fillText("ðŸŒ€ PORTAL ACTIVE! ðŸŒ€",280,60);
        ctx.restore();
      }

      // Game instructions bottom
      ctx.fillStyle='rgba(255,255,255,0.7)';
      ctx.font="16px Courier New";
      ctx.fillText(
        "Use ARROW KEYS to move â€¢ Collect all 3 KEYS â€¢ Avoid RED enemies",
        50, canvas.height-20
      );

      // Messages
      if(messageTimer>0){
        ctx.save();
        let alpha=Math.min(1,messageTimer/60);
        let mh=(animationTime*180)%360;
        ctx.fillStyle=`rgba(0,0,0,${alpha*0.8})`;
        let w=ctx.measureText(levelMessage).width;
        ctx.fillRect((canvas.width-w)/2-20,canvas.height/2-90,w+40,60);
        ctx.fillStyle=`hsla(${mh},100%,80%,${alpha})`;
        ctx.font="bold 28px Courier New";
        ctx.shadowColor=`hsl(${mh},100%,50%)`;
        ctx.shadowBlur=15;
        ctx.shadowOffsetX=2;
        ctx.shadowOffsetY=2;
        ctx.fillText(levelMessage,(canvas.width-w)/2,canvas.height/2-60);
        ctx.restore();
        messageTimer--;
      }

      // Start screen
      if(!gameStarted){
        ctx.save();
        ctx.fillStyle="rgba(0,0,0,0.85)";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        let th=(animationTime*60)%360;
        ctx.fillStyle=`hsl(${th},100%,70%)`;
        ctx.font="bold 36px Courier New";
        ctx.shadowColor=`hsl(${th},100%,50%)`;
        ctx.shadowBlur=25;
        let msg="âœ¨ PRESS ENTER TO START âœ¨";
        let tw=ctx.measureText(msg).width;
        ctx.fillText(msg,(canvas.width-tw)/2,canvas.height/2);
        ctx.font="20px Courier New";
        [
          "ðŸŽ® Use ARROW KEYS to move one square at a time",
          "ðŸ”‘ Collect 3 KEYS to activate the portal",
          "ðŸ”´ Avoid enemies â€“ they follow maze paths!",
          "ðŸ’Ž Collect DIAMONDS for bonus points",
          "ðŸŒ€ Enter the PORTAL to advance levels"
        ].forEach((line,i)=>{
          let ih=(th+i*60)%360;
          ctx.fillStyle=`hsl(${ih},100%,80%)`;
          ctx.shadowColor=`hsl(${ih},100%,60%)`;
          ctx.shadowBlur=10;
          let iw=ctx.measureText(line).width;
          ctx.fillText(line,(canvas.width-iw)/2,canvas.height/2+70+i*30);
        });
        ctx.restore();
      }

      // Game over
      if(gameOver){
        ctx.save();
        ctx.fillStyle="rgba(255,0,0,0