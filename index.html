<!DOCTYPE html>
<html>
<head>
  <title>Escape The Loop - Enhanced Edition</title>
  <style>
    body { 
      margin:0; 
      background: linear-gradient(135deg, #0a0a0a, #1a1a2e, #16213e); 
      color:white; 
      text-align:center; 
      font-family: 'Courier New', monospace;
      overflow: hidden;
    }
    canvas { 
      background: linear-gradient(45deg, #111, #222, #333); 
      display:block; 
      margin:10px auto; 
      border: 5px solid #00ff88;
      box-shadow: 0 0 40px rgba(0, 255, 136, 0.6), inset 0 0 20px rgba(255, 0, 255, 0.2);
      border-radius: 15px;
      max-width: 90vw;
      max-height: 85vh;
    }
    .title {
      font-size: 32px;
      color: #00ff88;
      text-shadow: 0 0 25px rgba(0, 255, 136, 1), 0 0 50px rgba(255, 0, 255, 0.5);
      margin: 10px 0;
      font-weight: bold;
    }
    .instructions {
      font-size: 18px;
      color: #ffaa00;
      margin: 5px 0;
      text-shadow: 0 0 10px rgba(255, 170, 0, 0.8);
    }
  </style>
</head>
<body>
  <div class="title">âœ¨ ESCAPE THE LOOP âœ¨</div>
  <div class="instructions">ðŸ”‘ Use ARROW KEYS to move â€¢ Collect 3 KEYS to activate portal â€¢ Avoid enemies ðŸ”´</div>
  <canvas id="gameCanvas" width="800" height="700"></canvas>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const tileSize = 45;
    const mazeOffsetX = 40;
    const mazeOffsetY = 80;

    let gameStarted = false,
        gameOver = false,
        victory = false,
        currentLevel = 0,
        score = 0,
        keysCollected = 0,
        messageTimer = 0,
        levelMessage = "",
        transitioning = false,
        transitionProgress = 0,
        animationTime = 0,
        moveDelay = 0;

    const MOVE_COOLDOWN = 8;

    let player = {
      x:1, y:1, targetX:1, targetY:1, floatX:1, floatY:1,
      angle:0, scale:1, moving:false, trail:[]
    };

    let keysPressed = {};
    document.addEventListener("keydown", e => {
      if (!gameStarted && e.key === "Enter") {
        gameStarted = true;
        resetLevel();
        return;
      }
      if ((e.key === "r" || e.key === "R")) {
        restartGame();
        return;
      }
      if (!keysPressed[e.key] && moveDelay <= 0) {
        keysPressed[e.key] = true;
        handleMovement(e.key);
      }
    });
    document.addEventListener("keyup", e => delete keysPressed[e.key]);

    function handleMovement(key) {
      if (gameOver || !gameStarted || messageTimer > 0 || victory || transitioning || player.moving) return;
      let dx = 0, dy = 0;
      if (key === "ArrowUp") dy = -1;
      if (key === "ArrowDown") dy = 1;
      if (key === "ArrowLeft") dx = -1;
      if (key === "ArrowRight") dx = 1;
      if (dx === 0 && dy === 0) return;

      let nx = player.x + dx,
          ny = player.y + dy,
          maze = levels[currentLevel].maze;
      if (maze[ny] && maze[ny][nx] === 0) {
        player.trail.push({ x: player.floatX, y: player.floatY, life: 20 });
        if (player.trail.length > 10) player.trail.shift();

        player.x = nx; player.y = ny;
        player.targetX = nx; player.targetY = ny;
        player.moving = true;
        moveDelay = MOVE_COOLDOWN;

        // Collect keys
        levels[currentLevel].keys = levels[currentLevel].keys.filter(k => {
          if (k.x === player.x && k.y === player.y) {
            keysCollected++;
            score += 100;
            levelMessage = `ðŸ”‘ Key collected! ${3 - keysCollected} keys remaining`;
            messageTimer = 60;
            return false;
          }
          return true;
        });
        // Collect diamonds
        levels[currentLevel].diamonds = levels[currentLevel].diamonds.filter(d => {
          if (d.x === player.x && d.y === player.y) {
            score += 500;
            levelMessage = "ðŸ’Ž Diamond collected! +500 points";
            messageTimer = 60;
            return false;
          }
          return true;
        });
      }
    }

    function updatePlayer() {
      if (player.moving) {
        let dx = player.targetX - player.floatX,
            dy = player.targetY - player.floatY,
            speed = 0.25;
        player.floatX += dx * speed;
        player.floatY += dy * speed;
        if (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1) {
          player.floatX = player.targetX;
          player.floatY = player.targetY;
          player.moving = false;
        }
      }
      player.trail.forEach(t => t.life--);
      player.trail = player.trail.filter(t => t.life > 0);
      if (moveDelay > 0) moveDelay--;
    }

    // --- SMARTER, SLOWER ENEMY AI ---

    // Directions: Up, Right, Down, Left
    const ENEMY_DIRS = [
      { x: 0, y: -1 },
      { x: 1, y: 0 },
      { x: 0, y: 1 },
      { x: -1, y: 0 }
    ];

    // BFS Pathfinder
    function findPath(sx, sy, tx, ty, maze) {
      const keyOf = p => `${p.x},${p.y}`;
      let frontier = [{ x: sx, y: sy }];
      let cameFrom = { [ keyOf({ x: sx, y: sy }) ]: null };

      while (frontier.length) {
        let cur = frontier.shift();
        if (cur.x === tx && cur.y === ty) break;
        for (let d of ENEMY_DIRS) {
          let nx = cur.x + d.x,
              ny = cur.y + d.y,
              k = keyOf({ x: nx, y: ny });
          if (maze[ny]?.[nx] === 0 && !(k in cameFrom)) {
            frontier.push({ x: nx, y: ny });
            cameFrom[k] = cur;
          }
        }
      }
      // Reconstruct path
      let path = [],
          step = { x: tx, y: ty };
      while (step) {
        path.unshift(step);
        step = cameFrom[keyOf(step)];
      }
      return path;
    }

    // Fallback random roaming
    function roamRandom(e, maze) {
      e.moveTimer++;
      if (e.moveTimer > 120) {
        let valid = [];
        ENEMY_DIRS.forEach((d, i) => {
          let nx = Math.floor(e.floatX + d.x),
              ny = Math.floor(e.floatY + d.y);
          if (maze[ny]?.[nx] === 0) valid.push(i);
        });
        if (valid.length) e.direction = valid[Math.floor(Math.random() * valid.length)];
        e.moveTimer = 0;
      }
      let d = ENEMY_DIRS[e.direction],
          nx = e.floatX + d.x * e.speed,
          ny = e.floatY + d.y * e.speed;
      if (maze[Math.floor(ny)]?.[Math.floor(nx)] === 0) {
        e.floatX = nx;
        e.floatY = ny;
      } else {
        e.moveTimer = 120;
      }
      e.x = Math.round(e.floatX);
      e.y = Math.round(e.floatY);
    }

    // Smart movement
    function moveEnemiesSmart() {
      let lvl = levels[currentLevel],
          maze = lvl.maze,
          px = player.x,
          py = player.y;

      lvl.enemies.forEach(e => {
        let ex = Math.floor(e.floatX),
            ey = Math.floor(e.floatY),
            dist = Math.hypot(px - ex, py - ey);

        if (dist < 7) {
          // chase
          e.repath = (e.repath || 0) - 1;
          if (e.repath <= 0) {
            e.path = findPath(ex, ey, px, py, maze);
            e.repath = 30;
          }
          if (e.path && e.path.length > 1) {
            let nxt = e.path[1],
                dx = nxt.x - e.floatX,
                dy = nxt.y - e.floatY,
                slow = e.speed * 0.4;
            e.floatX += dx * slow;
            e.floatY += dy * slow;
          } else {
            roamRandom(e, maze);
          }
        } else {
          // patrol
          roamRandom(e, maze);
        }

        // Collision
        if (Math.abs(e.floatX - player.floatX) < 0.7 &&
            Math.abs(e.floatY - player.floatY) < 0.7) {
          gameOver = true;
          levelMessage = "ðŸ’€ CAUGHT! Press R to restart ðŸ’€";
          messageTimer = 300;
        }
      });
    }

    // Enhanced portal pull, transitions, draw() and other functions remain unchanged...
    // (Copy the functions portalPull, handleTransition, resetLevel, restartGame, draw from your original code)

    // Replace your old loop:
    function loop() {
      if (gameStarted && !gameOver && !victory) {
        updatePlayer();
        moveEnemiesSmart();
        portalPull();
        handleTransition();
      }
      draw();
      requestAnimationFrame(loop);
    }
    loop();

    // --- LEVEL DATA, resetLevel, restartGame, portalPull, handleTransition, draw() ---
    // (Include the same level definitions and all other original helper functions here)

  </script>
</body>
</html>
