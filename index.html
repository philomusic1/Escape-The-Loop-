<!DOCTYPE html>
<html>
<head>
  <title>Escape The Loop - Ultimate Edition</title>
  <style>
    body { 
      margin:0; 
      background: linear-gradient(135deg, #0a0a0a, #1a1a2e, #16213e); 
      color:white; 
      text-align:center; 
      font-family: 'Courier New', monospace;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    canvas { 
      background: linear-gradient(45deg, #111, #222, #333); 
      display:block; 
      border: 6px solid #00ff88;
      box-shadow: 0 0 50px rgba(0, 255, 136, 0.8);
      border-radius: 15px;
    }
    .title {
      font-size: 36px;
      color: #00ff88;
      text-shadow: 0 0 30px rgba(0, 255, 136, 1);
      margin: 10px 0;
      font-weight: bold;
    }
    .info {
      font-size: 16px;
      color: #ffaa00;
      margin: 5px 0;
    }
    #startMessage {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      color: #00ff88;
      text-shadow: 0 0 30px rgba(0, 255, 136, 1);
      animation: pulse 2s infinite;
      z-index: 1000;
      background: rgba(0,0,0,0.8);
      padding: 50px;
      border-radius: 20px;
      border: 3px solid #00ff88;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
  </style>
</head>
<body>
<div class="title">ðŸŒŸ ESCAPE THE LOOP - ULTIMATE EDITION ðŸŒŸ</div>
<div class="info">Timer: <span id="timer">0.0</span>s | Score: <span id="score">0</span> | Level: <span id="level">1</span>/10</div>
<canvas id="gameCanvas" width="900" height="650"></canvas>

<div id="startMessage">
  ðŸŽ® CLICK HERE FIRST, THEN PRESS ENTER ðŸŽ®<br>
  <div style="font-size: 24px; margin-top: 20px;">
    Use ARROW KEYS to move â€¢ Collect KEYS ðŸ”‘ â€¢ Avoid ENEMIES ðŸ”´
  </div>
  <div style="font-size: 18px; margin-top: 15px; color: #ffaa00;">
    Click this box to focus, then press Enter to start!
  </div>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const tileSize = 30;
const mazeWidth = 28;
const mazeHeight = 20;
const mazeOffsetX = 20;
const mazeOffsetY = 50;

let gameStarted = false;
let gameOver = false;
let victory = false;
let currentLevel = 0;
let score = 0;
let keysCollected = 0;
let messageTimer = 0;
let levelMessage = "";
let animationTime = 0;
let gameTimer = 0;

let player = {
  x: 1, y: 1, floatX: 1, floatY: 1
};

// VERY SIMPLE KEY DETECTION
window.addEventListener('keydown', function(e) {
  console.log('Key:', e.key, 'Code:', e.code, 'KeyCode:', e.keyCode, 'gameStarted:', gameStarted);
  
  // Multiple ways to detect Enter
  if (e.key === 'Enter' || e.code === 'Enter' || e.keyCode === 13) {
    console.log('ENTER KEY DETECTED!');
    if (!gameStarted) {
      console.log('STARTING GAME!');
      document.getElementById('startMessage').style.display = 'none';
      gameStarted = true;
      resetLevel();
      return;
    }
  }
  
  if (e.key === 'r' || e.key === 'R') {
    console.log('RESTART KEY PRESSED');
    restartGame();
    return;
  }
  
  if (gameStarted && !gameOver && !victory) {
    movePlayer(e.key);
  }
});

// Add click handler for focus
document.getElementById('startMessage').addEventListener('click', function() {
  console.log('START MESSAGE CLICKED - focusing...');
  this.focus();
  this.style.border = '3px solid #ffaa00';
  this.style.outline = 'none';
});

// Make the start message focusable
document.getElementById('startMessage').setAttribute('tabindex', '0');

// Simple movement
function movePlayer(key) {
  let newX = player.x;
  let newY = player.y;
  
  if (key === 'ArrowUp') newY--;
  if (key === 'ArrowDown') newY++;
  if (key === 'ArrowLeft') newX--;
  if (key === 'ArrowRight') newX++;
  
  // Check if new position is valid
  if (maze[newY] && maze[newY][newX] === 0) {
    player.x = newX;
    player.y = newY;
    player.floatX = newX;
    player.floatY = newY;
    
    // Check for keys
    for (let i = keys.length - 1; i >= 0; i--) {
      if (keys[i].x === player.x && keys[i].y === player.y) {
        keys.splice(i, 1);
        keysCollected++;
        score += 100;
        levelMessage = `Key collected! ${keysCollected}/${keysNeeded} keys`;
        messageTimer = 60;
        break;
      }
    }
    
    // Check portal
    if (keysCollected >= keysNeeded && player.x === portalX && player.y === portalY) {
      currentLevel++;
      if (currentLevel >= totalLevels) {
        victory = true;
        levelMessage = "ðŸŽ‰ VICTORY! You escaped all levels! ðŸŽ‰";
        messageTimer = 300;
      } else {
        score += 500;
        resetLevel();
      }
    }
  }
}

// Simple maze generation
let maze = [];
let keys = [];
let enemies = [];
let keysNeeded = 3;
let portalX = 26;
let portalY = 18;
let totalLevels = 5;

function generateSimpleMaze() {
  // Create maze filled with walls
  maze = [];
  for (let y = 0; y < mazeHeight; y++) {
    maze[y] = [];
    for (let x = 0; x < mazeWidth; x++) {
      maze[y][x] = 1; // Start with all walls
    }
  }
  
  // Recursive backtracking maze generation
  function carvePath(x, y) {
    maze[y][x] = 0; // Mark as path
    
    // Get random directions
    let directions = [
      {dx: 0, dy: -2}, // Up
      {dx: 2, dy: 0},  // Right
      {dx: 0, dy: 2},  // Down
      {dx: -2, dy: 0}  // Left
    ];
    
    // Shuffle directions
    for (let i = directions.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [directions[i], directions[j]] = [directions[j], directions[i]];
    }
    
    // Try each direction
    for (let dir of directions) {
      let newX = x + dir.dx;
      let newY = y + dir.dy;
      
      // Check bounds
      if (newX > 0 && newX < mazeWidth - 1 && newY > 0 && newY < mazeHeight - 1) {
        // If the cell hasn't been visited
        if (maze[newY][newX] === 1) {
          // Carve the wall between
          maze[y + dir.dy / 2][x + dir.dx / 2] = 0;
          // Recursively carve from new position
          carvePath(newX, newY);
        }
      }
    }
  }
  
  // Start carving from position (1,1)
  carvePath(1, 1);
  
  // Ensure start position is clear
  maze[1][1] = 0;
  
  // Ensure portal area is accessible
  maze[portalY][portalX] = 0;
  maze[portalY-1][portalX] = 0;
  maze[portalY][portalX-1] = 0;
  
  // Add some extra connections to make maze less linear
  for (let attempts = 0; attempts < 20; attempts++) {
    let x = 1 + Math.floor(Math.random() * (mazeWidth - 2));
    let y = 1 + Math.floor(Math.random() * (mazeHeight - 2));
    
    if (maze[y][x] === 1) {
      // Check if this wall connects two paths
      let pathCount = 0;
      if (maze[y-1] && maze[y-1][x] === 0) pathCount++;
      if (maze[y+1] && maze[y+1][x] === 0) pathCount++;
      if (maze[y][x-1] === 0) pathCount++;
      if (maze[y][x+1] === 0) pathCount++;
      
      // If it connects paths, randomly remove it
      if (pathCount >= 2 && Math.random() < 0.3) {
        maze[y][x] = 0;
      }
    }
  }
  
  // Ensure there's always a path to the portal
  let pathX = 1, pathY = 1;
  while (pathX < portalX || pathY < portalY) {
    maze[pathY][pathX] = 0;
    
    if (pathX < portalX && Math.random() < 0.7) {
      pathX++;
    } else if (pathY < portalY) {
      pathY++;
    } else {
      pathX++;
    }
  }
}

function generateItems() {
  keys = [];
  enemies = [];
  
  // Place keys randomly
  for (let i = 0; i < keysNeeded; i++) {
    let x, y;
    do {
      x = Math.floor(Math.random() * (mazeWidth - 2)) + 1;
      y = Math.floor(Math.random() * (mazeHeight - 2)) + 1;
    } while (maze[y][x] !== 0 || (x === 1 && y === 1) || (x === portalX && y === portalY));
    
    keys.push({x: x, y: y, pulse: Math.random()});
  }
  
  // Place enemies
  let enemyCount = 2 + currentLevel;
  for (let i = 0; i < enemyCount; i++) {
    let x, y;
    do {
      x = Math.floor(Math.random() * (mazeWidth - 2)) + 1;
      y = Math.floor(Math.random() * (mazeHeight - 2)) + 1;
    } while (maze[y][x] !== 0 || (x === 1 && y === 1) || Math.abs(x - player.x) + Math.abs(y - player.y) < 5);
    
    enemies.push({
      x: x, y: y, floatX: x, floatY: y,
      direction: Math.floor(Math.random() * 4),
      moveTimer: 0,
      color: '#ff4444'
    });
  }
}

function resetLevel() {
  player.x = 1;
  player.y = 1;
  player.floatX = 1;
  player.floatY = 1;
  keysCollected = 0;
  keysNeeded = 3 + currentLevel;
  
  generateSimpleMaze();
  generateItems();
  
  levelMessage = `Level ${currentLevel + 1}: Collect ${keysNeeded} keys!`;
  messageTimer = 120;
}

function restartGame() {
  currentLevel = 0;
  score = 0;
  gameStarted = false;
  gameOver = false;
  victory = false;
  gameTimer = 0;
  document.getElementById('startMessage').style.display = 'block';
}

function updateEnemies() {
  enemies.forEach(enemy => {
    enemy.moveTimer++;
    if (enemy.moveTimer > 30) {
      enemy.moveTimer = 0;
      
      // Simple enemy movement
      let directions = [{x:0,y:-1}, {x:1,y:0}, {x:0,y:1}, {x:-1,y:0}];
      let validMoves = [];
      
      directions.forEach((dir, index) => {
        let newX = enemy.x + dir.x;
        let newY = enemy.y + dir.y;
        if (maze[newY] && maze[newY][newX] === 0) {
          validMoves.push(index);
        }
      });
      
      if (validMoves.length > 0) {
        enemy.direction = validMoves[Math.floor(Math.random() * validMoves.length)];
        let dir = directions[enemy.direction];
        enemy.x += dir.x;
        enemy.y += dir.y;
        enemy.floatX = enemy.x;
        enemy.floatY = enemy.y;
      }
    }
    
    // Check collision with player
    if (enemy.x === player.x && enemy.y === player.y) {
      gameOver = true;
      levelMessage = "ðŸ’€ CAUGHT! Press R to restart";
      messageTimer = 200;
    }
  });
}

function updateUI() {
  document.getElementById('timer').textContent = (gameTimer / 60).toFixed(1);
  document.getElementById('score').textContent = score;
  document.getElementById('level').textContent = currentLevel + 1;
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  if (!gameStarted) return;
  
  // Draw maze
  for (let y = 0; y < mazeHeight; y++) {
    for (let x = 0; x < mazeWidth; x++) {
      let drawX = mazeOffsetX + x * tileSize;
      let drawY = mazeOffsetY + y * tileSize;
      
      if (maze[y][x] === 1) {
        // Wall
        ctx.fillStyle = '#444466';
        ctx.fillRect(drawX, drawY, tileSize, tileSize);
        ctx.strokeStyle = '#666688';
        ctx.strokeRect(drawX, drawY, tileSize, tileSize);
      } else {
        // Floor
        ctx.fillStyle = '#222233';
        ctx.fillRect(drawX, drawY, tileSize, tileSize);
      }
    }
  }
  
  // Draw portal
  if (keysCollected >= keysNeeded) {
    let x = mazeOffsetX + portalX * tileSize + tileSize/2;
    let y = mazeOffsetY + portalY * tileSize + tileSize/2;
    
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(animationTime * 0.1);
    ctx.fillStyle = '#00ff88';
    ctx.shadowColor = '#00ff88';
    ctx.shadowBlur = 20;
    ctx.font = '24px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('ðŸŒ€', 0, 8);
    ctx.restore();
  }
  
  // Draw keys
  keys.forEach(key => {
    key.pulse += 0.1;
    let x = mazeOffsetX + key.x * tileSize + tileSize/2;
    let y = mazeOffsetY + key.y * tileSize + tileSize/2;
    let size = 16 + Math.sin(key.pulse) * 2;
    
    ctx.fillStyle = '#ffaa00';
    ctx.shadowColor = '#ffaa00';
    ctx.shadowBlur = 10;
    ctx.font = `${size}px Arial`;
    ctx.textAlign = 'center';
    ctx.fillText('ðŸ”‘', x, y + 5);
  });
  
  // Draw enemies
  enemies.forEach(enemy => {
    let x = mazeOffsetX + enemy.floatX * tileSize + tileSize/2;
    let y = mazeOffsetY + enemy.floatY * tileSize + tileSize/2;
    
    ctx.fillStyle = enemy.color;
    ctx.shadowColor = enemy.color;
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.arc(x, y, 12, 0, Math.PI * 2);
    ctx.fill();
  });
  
  // Draw player
  let px = mazeOffsetX + player.floatX * tileSize + tileSize/2;
  let py = mazeOffsetY + player.floatY * tileSize + tileSize/2;
  
  ctx.fillStyle = '#00ffff';
  ctx.shadowColor = '#00ffff';
  ctx.shadowBlur = 15;
  ctx.beginPath();
  ctx.arc(px, py, 10, 0, Math.PI * 2);
  ctx.fill();
  
  // Draw player emoji
  ctx.shadowBlur = 0;
  ctx.fillStyle = 'white';
  ctx.font = '16px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('ðŸ‘¤', px, py + 4);
  
  // Draw messages
  if (messageTimer > 0) {
    messageTimer--;
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(0, 10, canvas.width, 50);
    
    ctx.fillStyle = '#00ff88';
    ctx.font = '20px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(levelMessage, canvas.width/2, 40);
  }
  
  // Game over screen
  if (gameOver || victory) {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = gameOver ? '#ff4444' : '#00ff88';
    ctx.font = 'bold 32px Courier New';
    ctx.textAlign = 'center';
    
    if (gameOver) {
      ctx.fillText('ðŸ’€ GAME OVER ðŸ’€', canvas.width/2, canvas.height/2 - 20);
    } else {
      ctx.fillText(levelMessage, canvas.width/2, canvas.height/2 - 20);
    }
    
    ctx.font = '18px Courier New';
    ctx.fillText('Press R to restart', canvas.width/2, canvas.height/2 + 30);
  }
  
  updateUI();
}

function gameLoop() {
  animationTime += 0.1;
  if (gameStarted && !gameOver && !victory) {
    gameTimer++;
    updateEnemies();
  }
  draw();
  requestAnimationFrame(gameLoop);
}

// Initialize
resetLevel();
gameLoop();
</script>
</body>
</html>